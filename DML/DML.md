# Data Manipulation Language

- ### Insert
    - `INSERT INTO company(name, date) VALUES ('Google', '2011-01-01'), ('Facebook', '2012-01-01');` - вставка строчки в таблицу БД 
- ### Delete
    - `DELETE FROM company_storage.employee WHERE first_name = 'Test' RETURNING *;` - удаление строки таблицы 
      - `RETURNING *` - возращает удаленную строку
- ### Update
    - `UPDATE company_storage.employee SET salary = 10000 WHERE first_name = 'Test' RETURNING *;` - обновление строки таблицы
      - `SET` - устанавливаемые значения
      - `RETURNING *` - возращает обновленную строку
- ### Select
    - `SELECT DISTINCT name AS company, date FROM company WHERE (name != 'Facebook') AND (name LIKE '%o%') AND id IN (1, 2, 8, 9, 10, 11) ORDER BY name, date DESC LIMIT 2 OFFSET 2;` - выбор данных из таблицы
      - `name AS company` - переименовать выводимый столбец
      - `DISTINCT` - только уникальные значения
      - `ORDER BY name DESC` - отсоритровать по столбцу
      - `LIMIT 2` - количество выводимых значений
      - `OFFSET 2` - Смещение выводимых значений по таблице
      - `WHERE name != 'Facebook'` - фильтрация данных c условием
      - `WHERE name LIKE '%o%'` - фильтрация данных, LIKE - полное совпадение, % - не имеющие значение символы до или после
      - `WHERE date BETWEEN '2011-01-01' AND '2011-03-01'` - фильтрация данных, по диапазону BETWEEN и AND значениями 
      - `WHERE id IN (1, 2, 8, 9, 10, 11)` - фильтрация данных,из списка значений
      - `AND ... OR` - конъюнкция и дизъюнкция условий
      - `IS NOT NULL` - для сравнения на NULL используется IS, а не =  
- ### Functions
  - `SELECT sum(salary) AS sum, avg(salary) AS avg, max(salary) AS avg, min(salary) AS avg, count(salary) AS count, now() FROM employee;` - при
         - `sum` - сумма значений в столбце
         - `avg` - среднее значение в столбце
         - `max` - максимальное значение в столбце
         - `min` - минимальное значение в столбце
         - `count` - колличество столбцов в выборке not null, count(*) колличество всех столбцов в выборке
         - `now` - текущее время на сервере
  -`SELECT lower(first_name) AS fname, upper(last_name) as lname, concat(first_name, ' ', last_name) FROM employee;`
         - `lower` - перевод в нижний регистр
         - `upper` - перевод в верхний регистр
         - `concat` - конкатенация строк в столбце
- ### Union
  - `SELECT name, date FROM company WHERE id = 1 UNION ALL SELECT name, date FROM company WHERE id = 2` 
        -  `UNION ALL` - объединяет все результаты выборки из таблиц, UNION - выводит только уникальные (не повторяющиеся)
- ### Nested Request
    - `SELECT name FROM (SELECT * FROM company ORDER BY id DESC LIMIT 3) WHERE id IN (SELECT company_id FROM employee WHERE salary > 1000)`
      - можем подставлять подзапросы со столбцами с колонками в `FROM` и `WHERE`, сначала выполнится самый вложенный
    - `SELECT salary, (SELECT MAX(salary) AS max FROM employee) max from employee;`
      - можем подставлять значение в выводимые столбцы
    - `SELECT * FROM (VALUES ('Google', '2011-01-01'), ('Facebook', '2012-01-01'))`
      - можем подставлять `VALUES` из `INSERT` запроса т.к. это тоже данные со столбцами и строками
- ### JOIN
    - `SELECT (emp.first_name || ' ' || emp.last_name) AS employee, comp.name AS company, (c.phone || ' ' || c.type) AS contact  FROM company_storage.employee emp JOIN company_storage.company comp ON emp.company_id = comp.id JOIN company_storage.employeeid_contactid ec ON emp.id = ec.employeeId JOIN company_storage.contact c ON c.id = ec.contactId WHERE c.type = 'private';`
        - `JOIN` указываем таблицу `ON`указываем по каким строкам соединяем таблицы - отсекаются NULL значения из обоих таблиц
    - `SELECT (emp.first_name || ' ' || emp.last_name) AS employee, comp.name AS company FROM company_storage.employee emp LEFT JOIN company_storage.company comp ON emp.company_id = comp.id;`
        - отсекаются NULL соотношения значений из правой таблицы
    - `SELECT (emp.first_name || ' ' || emp.last_name) AS employee, comp.name AS company FROM company_storage.employee emp RIGHT JOIN company_storage.company comp ON emp.company_id = comp.id;`
        - отсекаются NULL соотношения значения из левой таблицы
    - `SELECT (emp.first_name || ' ' || emp.last_name) AS employee, comp.name AS company FROM company_storage.employee emp FULL JOIN company_storage.company comp ON emp.company_id = comp.id;`
        - показываются все null значения из таблиц